# -*- coding: utf-8 -*-
"""Basic-LSTM-Example-in-Keras.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E5NJDpw-VageUAhcXjrPI_Z_X7p0f4KQ
"""

import numpy as np
import matplotlib.pyplot as plt
from pandas import read_csv
import math
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from keras.layers import Input
from keras.models import Model

# %matplotlib inline

# fix random seed for reproducibility
np.random.seed(7)

window_size=3

# Per-month international passenger count (In thousands of passangers)
csv_filename='https://raw.githubusercontent.com/DiMorten/Basic-LSTM-Example-in-Keras/master/international-airline-passengers.csv'

"""To-do: Axes on figures

Load dataset and plot it
"""

# Load timeseries
dataframe = read_csv(csv_filename, usecols=[1], engine='python', skipfooter=3)
#dataframe = read_csv(csv_filename)
timeseries = dataframe.values
timeseries = timeseries.astype('float32')

print(dataframe.head())
plt.plot(timeseries)
plt.show()

# Normalize 
scaler = MinMaxScaler(feature_range=(0, 1))
timeseries = scaler.fit_transform(timeseries)

# Split into train and test sets
train_size = int(len(timeseries) * 0.67)
test_size = len(timeseries) - train_size
timeseries_train = timeseries[0:train_size,:]
timeseries_test = timeseries[train_size:len(timeseries),:]

print("Timeseries length: {}".format(timeseries.shape[0]))
print("Train set corresponds to the first {} samples from timeseries".format(timeseries_train.shape[0]))
print("Test set corresponds to the last {} samples from timeseries".format(timeseries_test.shape[0]))

"""Create dataset from timeseries applying a sliding window. 
Each sample predicts the next timestep value using information from previous and actual timesteps.

Input contains information from previous and actual timesteps: X=[timeseries(t-window_size),...,timeseries(t-1),timeseries(t)] 

Output corresponds to the next timestep: Y=timeseries(t+1)
"""

def create_dataset_from_timeseries(timeseries, window_size=1):
  X_data, Y_data = [], []
  for i in range(len(timeseries)-window_size-1):
    a = timeseries[i:(i+window_size), 0]
    X_data.append(a)
    Y_data.append(timeseries[i + window_size, 0])
  return np.array(X_data), np.array(Y_data)

X_train, Y_train = create_dataset_from_timeseries(timeseries_train, window_size) 
X_test, Y_test = create_dataset_from_timeseries(timeseries_test, window_size)

# Add a dimension to train and test input, so that their shape is: [samples, window_size, features]. 
# In this case there is only one feature and multiple time steps.
# Thus train and test input shape is: [samples, window_size, 1]
X_train = np.expand_dims(X_train, axis=2)
X_test = np.expand_dims(X_test, axis=2)

print("X_train.shape={}, Y_train.shape={}".format(X_train.shape,Y_train.shape))
print("X_test.shape={}, Y_test.shape={}".format(X_test.shape,Y_test.shape))

"""Define the LSTM model, the training loss and optimizer"""

lstm_units=4

model_in=Input(shape=(window_size,1)) # Input shape is (window_size, features). We only have 1 feature
x=LSTM(lstm_units)(model_in)	
model_out=Dense(1)(x) # Final layer has 1 neuron unit. We only predict one sample (The t+1 sample: Y=timeseries(t+1))
model=Model(model_in,model_out)

model.compile(loss='mean_squared_error', optimizer='adam')
model.summary()

"""Train the model"""

model.fit(X_train, Y_train, epochs=100, batch_size=1, verbose=2)

"""Predict and estimate prediction error (RMSE)"""

# Make predictions
trainPredict = model.predict(X_train)
testPredict = model.predict(X_test)

# Unnormalize predictions
trainPredict = scaler.inverse_transform(trainPredict)
Y_train = scaler.inverse_transform([Y_train])
testPredict = scaler.inverse_transform(testPredict)
Y_test = scaler.inverse_transform([Y_test])

# Calculate root mean squared error
trainScore = math.sqrt(mean_squared_error(Y_train[0], trainPredict[:,0]))
print('Train Score: %.2f RMSE' % (trainScore))
testScore = math.sqrt(mean_squared_error(Y_test[0], testPredict[:,0]))
print('Test Score: %.2f RMSE' % (testScore))

"""Plot train and test predictions for the final model"""

# shift train predictions for plotting
trainPredictPlot = np.empty_like(timeseries)
trainPredictPlot[:, :] = np.nan
trainPredictPlot[window_size:len(trainPredict)+window_size, :] = trainPredict
# shift test predictions for plotting
testPredictPlot = np.empty_like(timeseries)
testPredictPlot[:, :] = np.nan
testPredictPlot[len(trainPredict)+(window_size*2)+1:len(timeseries)-1, :] = testPredict
# plot baseline and predictions
plt.plot(scaler.inverse_transform(timeseries))
plt.plot(trainPredictPlot)
plt.plot(testPredictPlot)
plt.show()